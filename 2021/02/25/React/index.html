<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Tyrion"><title>React · Dolldoll</title><meta name="description" content="虚拟 DOMReact 不直接操作真实 DOM，而是通过渲染虚拟 DOM 到真实页面。因为有优秀的 DIFF 算法能够保证重用 DOM。JSX 语法定义虚拟 DOM 不写引号标签中有 JS 加{}样式类名不用 class 用 className内联样式要 style={ {key:value} }只"><meta name="keywords"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.slim.min.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css"><script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://hm.baidu.com/hm.js?200e3af61e111c5d45d04d11e6a30e54"></script><link rel="stylesheet" href="/css/base.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="stylesheet" href="/css/post.css"></head><body><div class="footer">Theme by <a href="https://dolldoll.design">doll </a>· Powered by <a href="https://hexo.io">Hexo </a>· Inspired by<a href="https://anyway.fm"> Anyway.fm</a><span>03 月 03 日</span></div><div class="frame-border ft"></div><div class="frame-border fb"></div><div class="frame-border fl"></div><div class="frame-border fr"></div><a class="back-btn" href="https://dolldoll.site" style="color:#fff">首页</a><div class="content animated fadeInDown"><article><h1>React</h1><div class="post-reading-time"><p>大概需要 4 分钟读完</p></div><h3>虚拟 DOM</h3><p>React 不直接操作真实 DOM，而是通过渲染虚拟 DOM 到真实页面。因为有优秀的 DIFF 算法能够保证重用 DOM。</p><h3>JSX 语法</h3><ol><li>定义虚拟 DOM 不写引号</li><li>标签中有 JS 加{}</li><li>样式类名不用 class 用 className</li><li>内联样式要 <code>style={ {key:value} }</code></li><li>只有一个根标签</li><li>标签必须闭合</li><li>标签首字母<ol><li>小写则转为 html 标签无论是否存在，例：div、name</li><li>大写则渲染为 react 对应组件，无则报错</li></ol></li></ol><h2>JS 的类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pet &#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Pet &#123;</span><br><span class="line">  constructor(name, age)&#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super()是调用父类的构造函数，也是将父类的 this 传递给子类，否则子类是用不了 this 对象的。</p><p>类定义的方法都是放在原型对象上。这句话引出的例子就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Weather extends React.Component &#123;</span><br><span class="line">  constructor(pros)&#123;</span><br><span class="line">    super(props);//调用父类构造器，传递this对象</span><br><span class="line">    this.changeWeather = this.changeWeather.bing(this);</span><br><span class="line">    //将原型对象上的changeWeather传递给Weather的实例对象并且绑定了this</span><br><span class="line">  &#125;</span><br><span class="line">  changeWeather() &#123;</span><br><span class="line">    //放在了Weather的原型对象上</span><br><span class="line">    //隐藏了&apos;use strict&apos;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>类中的 this</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">	constructor(name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">  study() &#123;</span><br><span class="line">    //类中的方法有隐形的&apos;use strict&apos;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const p1 = new Person(&apos;tom&apos;)</span><br><span class="line">p1.study() //this指向Person</span><br><span class="line">const x = p1.study //</span><br><span class="line">x() //等于函数直接调用study()，又因为严格模式所以输出的是undefined</span><br></pre></td></tr></table></figure><h3>类的简写</h3><p>首先的知识点就是在 class 里可以随便写赋值语句，但不可以随便写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Weather extends React.Component &#123;</span><br><span class="line">  //初始化state</span><br><span class="line">  state = &#123;</span><br><span class="line">    isHot:false,</span><br><span class="line">    wind:&apos;微风&apos;</span><br><span class="line">  &#125;</span><br><span class="line">	changeWeather = ()=&gt; &#123;</span><br><span class="line">    //changeWeather赋值了一个箭头函数</span><br><span class="line">    //箭头函数的this会直接在外层找，在这里就是Weather</span><br><span class="line">    console.log(this)//Weather</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>展开语法</h3><p>用于展开数组，在官方的情况下不能展开对象，但是可以用{…object}叫做构造字面量对象时使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//基本用法-合并</span><br><span class="line">const arr1 = [1,2,3,4]</span><br><span class="line">const arr2 = [3,4,5]</span><br><span class="line">const arr3 = [...arr1, ...arr2] // [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">//对象的使用场景</span><br><span class="line">const obj1 = &#123;foo:&apos;bar&apos;, x:23&#125;</span><br><span class="line">const obj2 = &#123;foo:&apos;bar&apos;, x:32&#125;</span><br><span class="line">const obj3 = &#123;...obj1, ...obj2&#125;</span><br><span class="line"></span><br><span class="line">//在React中可以展开对象是因为处于babel和react的编译中</span><br><span class="line">ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;, doucument.getElementById(&apos;test3&apos;))//仅在这里可用</span><br></pre></td></tr></table></figure><h2>Props</h2><p>组件接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。props 是只读的。</p><p>首先说一个 PropTypes 规定 prop 的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static propTypes = &#123;</span><br><span class="line">	name:PropTypes.string.isRequired,</span><br><span class="line">	age:PropTypes.number,</span><br><span class="line">	speak:PropTypes.func</span><br><span class="line">&#125;</span><br><span class="line">static defaultProps = &#123;</span><br><span class="line">	sex:&apos;男&apos;,</span><br><span class="line">	age:18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>Ref</h2><p>下面是几个适合使用 refs 的情况：</p><ul><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//string类型的方式会有“性能不好”的问题</span><br><span class="line">&lt;input ref = &quot;input1&quot;&gt;&lt;/input&gt;</span><br><span class="line"></span><br><span class="line">//最常用</span><br><span class="line">//回调函数的方式在更新过程中会被调用两次，一次null，一次真实DOM对象，但大部分情况无关紧要</span><br><span class="line">&lt;input ref =&#123; c =&gt; this.input1 = c&#125;&gt;&lt;/input&gt;</span><br><span class="line">//定义成绑定class的绑定函数解决上述问题</span><br><span class="line">saveInput = (c) =&gt; this.input1 = c;</span><br><span class="line">&lt;input ref =&#123;this.saveInput&#125;&gt;&lt;/input&gt;</span><br><span class="line"></span><br><span class="line">//最推荐</span><br><span class="line">//React.createRef 调用后生成一个容器，用于储存ref标识的节点</span><br><span class="line">input1 = React.createRef()</span><br><span class="line">......//省略代码</span><br><span class="line">&lt;input ref=&#123;this.input1&#125;&gt;&lt;/input&gt;</span><br><span class="line">//使用的时候是</span><br><span class="line">console.log(this.input1.current.value)</span><br></pre></td></tr></table></figure><h2>Fragment</h2><p>用来躲避 JSX 必须要指定一个根标签的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Fragment&#125; from &apos;react&apos;</span><br><span class="line">...</span><br><span class="line">&lt;Fragment key=&#123;&#125;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/Fragment&gt;</span><br></pre></td></tr></table></figure><h2>Context</h2><p>用来在<strong>祖组件</strong>和<strong>后代组件</strong>中传递状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const XxxContext = React.createContext()</span><br><span class="line"></span><br><span class="line">&lt;XxxContext.Provider value =&#123;数据，可是对象&#125;</span><br><span class="line">子组件</span><br><span class="line">&lt;/XxxContext.Provider&gt;</span><br><span class="line"></span><br><span class="line">//方式一：仅适用于类组件</span><br><span class="line">static contextType = XxxContext</span><br><span class="line">this.context//可以读取了</span><br><span class="line">//方式二：引入Consumer</span><br><span class="line">&lt;XxxContext.Consumer&gt;</span><br><span class="line">&#123;</span><br><span class="line">	value =&gt; &#123;value就是返回的数据&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><h2>PureComponent</h2><p>Component 中，只要执行 setState()，即使不改变状态，依旧调用 render()，父组件的 render()会触发子组件的 render()。</p><p>原因：Component 中的 shouldComponentUpdate()总返回 true。</p><p>而 PureComponent 解决了上述问题。</p><p>但：</p><ol><li>只进行 props 和 state 的浅比较，如果只是对象内部数据改变，那不会触发 render()</li><li>子组件也要是 PureComponent。</li></ol><h2>RenderProps</h2><p>类似 Vue 的 slot，可以在父组件中传一个子组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent render=&#123;(name)=&gt;&lt;Son name=&#123;name&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">//父组件中jsx加上</span><br><span class="line">&#123;this.props.render(this.state.name)&#125;</span><br></pre></td></tr></table></figure><h2>ErrorBoundary</h2><p>只能用在生产环境，开发环境使用会照样报错.</p><p>getDerivedStateFromError 和 componentDidCatch 一般配合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; hasError: false &#125;;</span><br><span class="line">static getDerivedStateFromError(error) &#123;</span><br><span class="line">	return &#123; hasError: true &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">	//统计页面的错误，发送请求到后台</span><br><span class="line">	console.log(error, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;div&gt;&#123;hasError ? &lt;h2&gt;当前网络不稳定，稍后再试&lt;/h2&gt; : &lt;Child /&gt;&#125;&lt;/div&gt;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>Hooks</h2><h3>useState</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// useState返回一个数组，接收一个参数设置为初始值</span><br><span class="line">// 数组第一个为变量名，接受参数为初始值</span><br><span class="line">// 第二个为设置变量的函数</span><br><span class="line">const [count, setCount] = useState(0)</span><br></pre></td></tr></table></figure></article><div class="post-footer"><span class="date">2021年02月25日</span><span class="tag"><a title="芝士碎片">芝士碎片</a></span></div></div><script src="/js/utils.js"></script></body></html>